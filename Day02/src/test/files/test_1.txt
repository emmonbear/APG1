Если бы мы использовали канал без буферизации, две более медленные go-
подпрограммы были бы заблокированы при попытках отправить свои ответы в канал,
из которого никто никогда не пытался бы считывать данные. Эта ситуация, которая
называется утечкой go-подпрограмм, была бы ошибкой. В отличие от переменных,
потерянные go-подпрограммы не собираются сборщиком мусора автоматически, по­
этому важно гарантировать, что go-подпрограммы должны прекратиться сами, когда
они больше не нужны.
Выбор между буферизованными и небуферизованными каналами, как и выбор ем­
кости буферизованных каналов, может влиять на корректность работы программы.
Небуферизованные каналы дают более надежные гарантии синхронизации, потому
что каждая операция отправления синхронизируется с соответствующей операцией
получения; в случае буферизованных каналов эти операции разделены. Кроме того,
когда мы знаем верхнюю границу количества значений, отправляемых в канал, нет
ничего необычного в создании буферизованного канала данного размера с выполне­
нием всех отправлений еще до получения первого значения из канала. Неспособность
выделить достаточную емкость буфера может привести ко взаимоблокировке про­
граммы.
Буферизация канала может повлиять и на производительность программы. Пред­
ставьте себе трех кондитеров, из которых один печет торт, второй поливает его гла­
зурью, а третий разукрашивает торт перед передачей на продажу. В кухне, где мало
места, каждый кондитер, который закончил свою операцию с тортом, вынужден до­
жидаться, когда следующий кондитер будет готов принять его работу. Это аналог ка­
нала связи без буферизации.
Если же между кондитерами есть место для одного торта, то кондитер может по­
ставить там готовый торт и браться за следующий. Это аналог канала с буфером емко­
стью 1. Если кондитеры работают в среднем примерно одинаково, большинство тор­
тов пройдут быстро: временные различия в работе будут сглажены наличием буфера.
Чем больше места между поварами — т.е. чем больше буфера, — тем более сильные
вариации будут сглажены без приостановки конвейера (как, например, если один по­
вар вынужден ненадолго отлучиться, после чего наверстывает упущенное).
С другой стороны, если на более ранней стадии конвейера работа идет быстрее,
чем на следующем этапе, буфер между ними будет большую часть времени заполнен.
И наоборот, если на последующей стадии работа идет быстрее, буфер в основном
пусты. В этом случае буфер не приносит никакой пользы.
Метафора такого конвейера полезна для каналов и go-подпрограмм. Например,
если работа на втором этапе является более сложной, то один кондитер может не
иметь возможности обеспечить необходимую скорость, так что мы могли бы нанять
еще одного кондитера ему в помощь — для выполнения той же задачи, но работаю­
щего самостоятельно. Это аналогично созданию еще одной go-подпрограммы, сооб­
щающейся с другими через те же каналы.